---
title: "5.5 積"
---

次は積の普遍的構成を見ていこう．二つの集合のカーテジアン積は，ご存知の通り組のなす集合である．だが積集合とその構成要素である集合とをつなぐパターンは何だろう．それが分かれば他の圏にも一般化できる．

我々が言えることは，積からそれぞれの構成要素への二つの関数，あるいは射影が存在するということのみである．Haskellでは，それらの二つの関数は $fst$ 及び $snd$ と呼ばれ，それぞれ組の一番目と二番目の構成要素を選ぶ．

```haskell
fst :: (a, b) -> a
fst (x, y) = x
```

```haskell
snd :: (a, b) -> b
snd (x, y) = y
```

ここで，これらの関数はその引数に当てはまるパターンによって定義される．任意の組に当てはまるパターンは $(x, y)$ であり，それは構成要素から変数 $x$ と $y$ を抜き出す． 

ワイルドカードを用いることで，これらの定義は更にシンプルにできる．

```haskell
fst (x, _) = x
snd (_, y) = y
```

以下の例のように，C++ではテンプレート関数を用いる．

```cpp
template<class A, class B> A
fst(pair<A, B> const & p) {
    return p.first;
}
```

この一見非常に限られた知識を用いて，集合の圏の，対象と射のパターンを定義してみよう．それによって二つの集合 $a$ と $b$ の積の構成が得られる．このパターンは対象 $c$ と，$c$ をそれぞれ $a$ と $b$ につなぐ二つの射 $p$ と $q$ から成る．

```haskell
p :: c -> a
q :: c -> b
```

![](https://storage.googleapis.com/zenn-user-upload/888670ed3e3c716f11c1674f.jpg)

このパターンに当てはまる全ての $c$ が，積の候補として考えられるだろう．それらはたくさんあるかもしれない．

![](https://storage.googleapis.com/zenn-user-upload/f219944219dff4ec9299616c.jpg)

例えば構成要素として，二つのHaskell型 $Int$ と $Bool$ を選び，その積の候補のサンプリングを得る．

ここで，$Int$ は $Int$ と $Bool$ の積の候補として考えられるだろうか．答えは可能であり，そしてこれがその射影だ．

```haskell
p :: Int -> Int
p x = x

q :: Int -> Bool
q _ = True
```

とてもぎこちないが，これも基準に当てはまる．

$(Int, Int, Bool)$ は三つの要素のタプル，もしくはトリプルだ．これを積の正当な候補にする，二つの射が存在する（トリプルのパターンマッチングを用いている）．

```haskell
p :: (Int, Int, Bool) -> Int
p (x, _, _) = x

q :: (Int, Int, Bool) -> Bool
q (_, _, b) = b
```

一つ目の候補は小さすぎる（積の $Int$ 次元を対象とするのみ）が，二つ目の候補は大きすぎる（驚くべきことに $Int$ の二倍の次元を対象とする）ことに気づいたかもしれない．

だが我々はまだ，普遍的構成の他の部分，すなわち順位付けについて調べていない．パターンの二つの対象を比べたい．ある候補の対象 $c$ ないしその二つの射影 $p$ 及び $q$ と，別の候補の対象 $c'$ ないしその二つの射影 $p'$ 及び $p'$とを比べたい．もし $c'$ から $c$ への射 $m$ が存在すれば，$c$ が $c'$ よりも「より良い」と言いたいが，これでは弱すぎる．この場合 $c$ の射影が $c'$ の射影よりも，「より良い」もしくは「より普遍的である」としたい．これは射影 $p'$ と $q'$ が，$m$ を用いて $p$ と $q$ から再構成されることを意味する．

```haskell
p' = p . m
q' = q . m
```

![](https://storage.googleapis.com/zenn-user-upload/8c02fd279d8e0ada951a6260.jpg)

この方程式を，$m$ が $p'$ と $q'$ を **因数分解している** と見ることもできる．これらを自然数についての方程式をとみなし，ドットを乗算だとすると，$m$は $p'$ と $q'$ の共通因子である．

直感を得るために，二つの標準的な射影 $fst$ と $snd$ をもつ組 $(Int, Bool)$ が，実は先程あげた二つの候補よりも**より良い**ことをお見せしよう．

![](https://storage.googleapis.com/zenn-user-upload/1fb8cce0bfa2bf05833a95a0.jpg)

一つ目の候補に対する写像 $m$ は，

```haskell
m :: Int -> (Int, Bool)
m x = (x, True)
```

実際，二つの射影 $p$ と $q$ は以下のように再構成される．

```haskell
p x = fst (m x) = x
q x = snd (m x) = True
```
二つ目の例に対する写像$m$も同様に一意に定まる．

```haskell
m (x, _, b) = (x, b)
```

$(Int, Bool)$は他の二つの候補よりも良いことが示せた．なぜその逆が正しくないかを見てみよう．$p$ と $q$ から $fst$ と $snd$ を再構成するような $m'$ を見つけることができるだろうか．

```haskell
fst = p . m'
snd = q . m'
```

一つ目の例では，$q$ は常に $True$ を返し，二つ目の要素が $False$ であるような組が存在することを知っている．$q$ から $snd$ を再構成することはできない．

二つ目の例では事情が異なる．我々は $p$ もしくは $q$ を作用させたあとに十分な情報を持っているが， $fst$ と $snd$ を因数分解する一つ以上の方法が存在する．$p$ も $q$ もトリプルの二つ目の要素を無視するので，$m'$ はそこに何でもいれることができる．例えば，

```haskell
m' (x, b) = (x, x, b)
```

他にもこのように．

```haskell
m' (x, b) = (x, 42, b)
```

まとめると，二つの射影 $p$ と $q$ を持つ任意の型 $c$ が与えられた時に，それらを因数分解する，$c$ からカーテジアン積 $(a,b)$ への一意な写像 $m$ が存在する． 実際，それは $p$ と $q$ を組にするだけである．

```haskell
m :: c -> (a, b)
m x = (p x, q x)
```

この写像はカーテジアン積と最も相性がよい．つまりこの普遍的構成は集合の圏でうまく使える．それは任意の二つの集合の積を取り出す．

集合のことは一旦忘れ，今度は同じ普遍的構成を用いて，任意の圏における二つの対象の積を定義しよう．そのような積は常に存在するとは限らないが，もし存在すれば，一意の同型を除いて一意である．

> 二つの対象 $a$ と $b$ の**積**とは，二つの射影をもつ任意の他の対象 $c'$ に対して，$c'$ から $c$ への一意な射 $m$ が存在するような，二つの射影をもつ対象 $c$ である．

二つの候補から因数分解する関数 $m$ を返すような（高階）関数は，時に **factorizer** と呼ばれる．ここではこのような関数である．

```haskell
factorizer :: (c -> a) -> (c -> b) -> (c -> (a, b))
factorizer p q = \x -> (p x, q x)
```

(和訳：[@dshin](https://zenn.dev/dshin))
