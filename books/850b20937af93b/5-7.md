---
title: "5.7 非対称性"
---

これまで二組の双対の定義を見てきた．終対象の定義は，始対象の定義から矢印を反転することで得られた．同様にして余積の定義も，積の定義から得られた．しかし集合の圏では，始対象は終対象とはまるで別物だし，積も余積とはまるで別物だ．後ほど説明するが，積は乗算のようなものとして振る舞い，終対象はそのなかで単位元として振る舞う．一方で，余積は和のようなものとして振る舞い，始対象はそのなかで零元のように振る舞う．特に有限集合では，積の大きさは個々の集合の大きさの積であり，余積の大きさは個々の大きさの和である．

このことは，集合の圏は矢印の反転について対称ではないことを示している．

空集合は任意の集合への一意な射（`absord` 関数）を持つが，任意の集合からの射は持たないことに注意してほしい．シングルトン集合は任意の集合からの一意な射を持つが，（空集合を除く）全ての集合への射も持つ．以前見たとおり終対象からの射は，他の集合から要素を取り出す際に重要な役目を演じる（空集合は要素をもたないので，そもそも選ぶ要素がない）．

これが積と余積を区別する，シングルトン集合と積との間の関係である．単位型 `{}` で表されるシングルトン集合を用いて，更にもう一つの（大いに劣った）積のパターンの候補を考えよう．そこにシングルトンからそのそれぞれの要素集合への関数である，二つの射影  `p` と `q` を付け加えよう．これらは具体的な要素をそれぞれの集合から選ぶ．積は普遍的なので，我々の候補であるシングルトンから積への（一意の）射 `m` もまた存在する．この射は積集合から要素を選ぶ，すなわち具体的な組を選ぶ．それは以下のように二つの射影を因数分解する．

```haskell
p = fst . m
q = snd . m
```

シングルトン集合の唯一の要素である，シングルトンの値 `()` に作用した時，二つの方程式は以下のようになる．

```haskell
p () = fst (m ())
q () = snd (m ())
```

`m ()` は `m` によって取り出された積の要素なので，一つ目の集合から `p` によって取り出された要素 `p ()` が，`m` によって取り出された組の一つ目の要素であることを，これらの方程式は示している．同様に `q ()` は二つ目の要素に等しい．このことは積の要素が，要素集合から取り出された要素の組であるという我々の理解と一致する．

余積には単純な解釈はない．余積の候補としてシングルトン集合を考え，そこから要素を取り出そうとすることはできるが，その場合二つの外向きの射影ではなく，内向きの射影が得られるだろう．それらはどこから来たのかについて何の情報も持たない（実際入力パラメータを無視することを見た）．余積からシングルトンへの一意の射も存在しない．集合の圏を始対称から見た時，終端から見たときとは全く異なってみえる．

これは集合の内在的な性質ではなく，`Set` の射として用いている関数の性質である．一般に関数は非対称であることを説明しよう．

関数は，定義域の集合（プログラミングでは，**全** (total) 関数とよばれる）の全ての要素について定義されていなければならないが，全ての余域を対象とする必要はない．既にその極端な例（シングルトン集合からの関数）を見た．それらの関数は余域から要素を一つ取り出す（空集合からの関数が実に極端な例である）．定義域の大きさが余域よりもずっと小さい場合，しばしばそのような関数を定義域の余域への埋め込みと考える．例えばシングルトン集合からの関数を，余域への要素の埋め込みとして考える事ができる．そのような関数を**埋め込み** (embedding) 関数と呼ぶことにするが，数学者は反対の名前を与えることを好む．余域を密に満たす関数は**全射** (surjective or onto) と呼ばれる．

非対称の別の要因は，関数が定義域の複数の要素を余域の一つの要素に写すことである．そのような関数は複数の要素を潰せる．極端な例は，全ての集合をシングルトンへと写す関数である．多態的関数 `unit` がその例であることを以前見てきた．潰しは合成によってのみ構成される．二つの潰し関数の合成は，個々の関数より上位の潰しとなる．数学者は潰しでない関数を**単射** (injective or one-to-one) と呼ぶ．

もちろん埋め込みでも潰しでもない関数も存在する．それらは**全単射** (bijection) と呼ばれ，可逆であるために真に対称である．集合の圏では，同型は全単射と同じである．

(和訳：[@dshin](https://zenn.dev/dshin))
